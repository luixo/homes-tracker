import type { GetServerSideProps, NextPage } from "next";
import Head from "next/head";
import React from "react";
import { styled } from "../client/styles";
import {
  CheckData,
  checkers,
  extractTimestampFromKey,
  getLastKeys,
} from "../server/checkers";
import { globalLogger } from "../server/logger";
import { getS3Keys } from "../server/services/s3";

const Wrapper = styled("div", {
  padding: "0 1rem",
});

const Main = styled("main", {
  minHeight: "100vh",
  flex: 1,
  display: "flex",
  flexDirection: "column",
});

const TimeSlice = styled("div", {
  padding: 20,
});

const Timestamp = styled("div", {
  paddingLeft: 16,
});

const CheckerHeader = styled("div", {
  paddingTop: 16,
});

const CheckerMessages = styled("div", {
  fontFamily: "monospace",
  whiteSpace: "pre-wrap",
  display: "flex",
  flexDirection: "column",
});

const CheckerMessage = styled("a", {
  textDecoration: "underline",
});

type Props = {
  timeSlices: {
    result: CheckData<unknown>;
    timestamp: string;
  }[];
  error?: string;
};

const Home: NextPage<Props> = (props) => {
  return (
    <Wrapper>
      <Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <Main>
        {props.timeSlices.map((timeSlice, sliceIndex) => {
          return (
            <TimeSlice key={timeSlice.timestamp}>
              <Timestamp>
                {new Date(Number(timeSlice.timestamp)).toLocaleString()}
              </Timestamp>
              {sliceIndex === props.timeSlices.length - 1 ? (
                <CheckerHeader>This is base result</CheckerHeader>
              ) : (
                timeSlice.result.map((result) => {
                  const checker = checkers[result.id];
                  const messages = checker.getMessages(result.results);
                  if (messages.length === 0) {
                    return null;
                  }
                  return (
                    <React.Fragment key={result.id}>
                      <CheckerHeader>{result.id}</CheckerHeader>
                      <CheckerMessages>
                        {messages.map((message, index) => {
                          return (
                            <CheckerMessage
                              key={index}
                              href={message.url}
                              target="_blank"
                            >
                              {message.description}
                            </CheckerMessage>
                          );
                        })}
                      </CheckerMessages>
                    </React.Fragment>
                  );
                })
              )}
            </TimeSlice>
          );
        })}
        {props.error ? (
          <>
            <div>Error:</div>
            <div>{props.error}</div>
          </>
        ) : null}
      </Main>
    </Wrapper>
  );
};

export const getServerSideProps: GetServerSideProps<Props> = async (
  context
) => {
  const logger = globalLogger.child({ handler: "index" });
  const amount = Number(context.query.amount ?? 5);
  try {
    const lastKeys = await getLastKeys(logger);
    const timeSlices = await getS3Keys<CheckData<unknown>>(
      logger,
      lastKeys.slice(0, amount)
    );
    return {
      props: {
        timeSlices: timeSlices.map((timeSlice, sliceIndex) => {
          return {
            result: timeSlice.map((checkerData) => {
              const checkerDefinition = checkers[checkerData.id];
              const nextTimeSlice = timeSlices[sliceIndex + 1];
              if (!nextTimeSlice) {
                return checkerData;
              }
              const nextCheckerData = nextTimeSlice.find(
                (someChecker) => someChecker.id === checkerData.id
              );
              if (!nextCheckerData) {
                return checkerData;
              }
              return {
                id: checkerData.id,
                results: checkerDefinition.getNewResults(
                  checkerData.results,
                  nextCheckerData.results
                ) as typeof checkers,
              };
            }),
            timestamp: extractTimestampFromKey(lastKeys[sliceIndex]),
          };
        }),
      },
    };
  } catch (e) {
    return {
      props: {
        timeSlices: [],
        error: String(e),
      },
    };
  }
};

export default Home;
